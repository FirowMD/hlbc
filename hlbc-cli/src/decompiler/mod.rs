//! The decompiler used to get haxe sources back from the bytecode definitions.
//! More info on how everything works in the wiki : [https://github.com/Gui-Yom/hlbc/wiki/Decompilation]

use std::collections::{HashMap, HashSet};
use std::fmt::Write;

use hlbc::opcodes::Opcode;
use hlbc::types::{Function, RefField, RefGlobal, Reg, Type, TypeObj};
use hlbc::Bytecode;

use crate::decompiler::ast::{
    add, constant_bool, decr, gte, incr, not, sub, Constant, ConstructorCall, Expression,
    LoopScope, Scope, ScopeType, Scopes, Statement,
};

/// A simple representation for the Haxe source code generated by the decompiler
mod ast;
/// Functions to render the [ast] to a string
mod fmt;

pub struct FormatOptions {
    indent: String,
    inc_indent: String,
}

impl FormatOptions {
    pub fn new(inc_indent: &str) -> Self {
        Self {
            indent: String::new(),
            inc_indent: inc_indent.to_string(),
        }
    }

    pub fn with_base_indent(indent: &str, inc_indent: &str) -> Self {
        Self {
            indent: indent.to_string(),
            inc_indent: inc_indent.to_string(),
        }
    }

    pub fn inc_nesting(&self) -> Self {
        FormatOptions {
            indent: format!("{}{}", self.indent, self.inc_indent),
            inc_indent: self.inc_indent.clone(),
        }
    }
}

pub fn decompile_class(code: &Bytecode, obj: &TypeObj) -> String {
    let mut buf = String::with_capacity(1024);

    let mut is_static = false;
    writeln!(
        &mut buf,
        "class {} {}{{",
        obj.name.display(code),
        if let Some(e) = obj.super_ {
            is_static = e.0 == 12;
            format!("extends {} ", e.display(code))
        } else {
            "".to_string()
        }
    )
    .unwrap();
    let indent = FormatOptions {
        indent: String::new(),
        inc_indent: "  ".to_string(),
    };
    for (i, f) in obj
        .fields
        .iter()
        .enumerate()
        .skip(obj.fields.len() - obj.own_fields.len())
    {
        if obj.bindings.get(&RefField(i)).is_some() {
            continue;
        }
        writeln!(
            &mut buf,
            "{indent}{}var {}: {}",
            if is_static { "static " } else { "" },
            f.name.display(code),
            f.t.display(code)
        )
        .unwrap();
    }
    writeln!(&mut buf, "// BINDINGS").unwrap();

    for fun in obj.bindings.values() {
        //let fi = &obj.fields[fi.0];
        let fun = fun.resolve_as_fn(code).unwrap();
        writeln!(
            &mut buf,
            "{indent}{}{}{}{indent}}}\n",
            if is_static { "static " } else { "" },
            decompile_function_header(code, fun),
            decompile_function_body(code, &indent.inc_nesting(), fun)
        )
        .unwrap();
    }

    writeln!(&mut buf, "// METHODS").unwrap();

    for f in &obj.protos {
        let f = f.findex.resolve_as_fn(code).unwrap();
        writeln!(
            &mut buf,
            "{indent}{}{}{indent}}}\n",
            decompile_function_header(code, f),
            decompile_function_body(code, &indent.inc_nesting(), f)
        )
        .unwrap();
    }
    writeln!(&mut buf, "}}").unwrap();
    buf
}

pub fn decompile_function_header(code: &Bytecode, f: &Function) -> String {
    let mut buf = String::with_capacity(256);

    write!(&mut buf, "function {}(", f.name.unwrap().display(code)).unwrap();

    match f.t.resolve(&code.types) {
        Type::Fun(fun) => {
            // Skip the first because its a method (this)
            for (i, a) in fun.args.iter().enumerate().skip(1) {
                if i != 1 {
                    write!(&mut buf, ", ").unwrap();
                }
                write!(&mut buf, "reg{}: {}", i, a.display(code)).unwrap();
            }
            writeln!(
                &mut buf,
                "): {} {{ // {}",
                fun.ret.display(code),
                f.findex.0
            )
            .unwrap();
        }
        _ => {
            unreachable!()
        }
    }
    buf
}

pub fn decompile_closure(code: &Bytecode, indent: &FormatOptions, f: &Function) -> String {
    let mut buf = String::with_capacity(256);

    write!(&mut buf, "(").unwrap();

    match f.t.resolve(&code.types) {
        Type::Fun(fun) => {
            // Skip the first because its a method (this)
            for (i, a) in fun.args.iter().enumerate().skip(1) {
                if i != 1 {
                    write!(&mut buf, ", ").unwrap();
                }
                write!(&mut buf, "reg{}: {}", i, a.display(code)).unwrap();
            }
            writeln!(&mut buf, ") -> {{ // {}", f.findex.0).unwrap();
        }
        _ => {
            unreachable!()
        }
    }
    write!(
        &mut buf,
        "{}",
        decompile_function_body(code, &indent.inc_nesting(), f)
    )
    .unwrap();

    writeln!(&mut buf, "{indent}}}").unwrap();
    buf
}

pub fn decompile_function_body(code: &Bytecode, indent: &FormatOptions, f: &Function) -> String {
    let mut buf = String::with_capacity(256);

    for a in f
        .assigns
        .as_ref()
        .unwrap()
        .iter()
        .map(|(s, i)| format!("{} at opcode {}", s.resolve(&code.strings), i - 1))
    {
        writeln!(&mut buf, "{indent}{a}").unwrap();
    }
    writeln!(&mut buf).unwrap();

    for stmt in make_statements(code, f) {
        stmt.display(&mut buf, indent, code, f).unwrap();
    }

    buf
}

fn make_statements(code: &Bytecode, f: &Function) -> Vec<Statement> {
    // Holds the statements, handles the scopes
    let mut scopes = Scopes::new();
    // Current iteration statement, to be pushed onto the finished statements or the nesting
    let mut statement = None;
    // Expression values for each registers
    let mut reg_state = HashMap::with_capacity(f.regs.len());
    // Some when we're parsing a constructor call (between New and Call)
    let mut constructor_ctx = None;
    // Variable names we already declared
    let mut seen = HashSet::new();

    // Initialize register state with the function arguments
    for i in 0..f.ty(code).args.len() {
        reg_state.insert(
            Reg(i as u32),
            Expression::Variable(Reg(i as u32), f.arg_name(code, i)),
        );
    }

    // Create a statement and update the register state (depending on inline rules)
    macro_rules! push_expr {
        ($i:expr, $dst:expr, $e:expr) => {
            let name = f.var_name(code, $i);
            let expr = $e;
            // Inline check
            if name.is_none() {
                reg_state.insert($dst, expr);
            } else {
                reg_state.insert($dst, Expression::Variable($dst, name.clone()));
                if seen.insert(name.clone().unwrap()) {
                    statement = Some(Statement::NewVariable {
                        reg: $dst,
                        name,
                        assign: expr,
                    });
                } else {
                    statement = Some(Statement::Assign {
                        reg: $dst,
                        name,
                        assign: expr,
                    });
                }
            }
        };
    }

    // Get the expr for a register
    macro_rules! expr {
        ($reg:expr) => {
            reg_state.get(&$reg).expect("No expr for reg ?").clone()
        };
    }

    macro_rules! make_args {
        ($($arg:expr),*) => {
            vec![$(expr!($arg)),*]
        }
    }

    let iter = f.ops.iter().enumerate();
    for (i, o) in iter {
        //println!("ITER");
        match *o {
            Opcode::Int { dst, ptr } => {
                push_expr!(
                    i,
                    dst,
                    Expression::Constant(Constant::Int(ptr.resolve(&code.ints)))
                );
            }
            Opcode::Float { dst, ptr } => {
                push_expr!(
                    i,
                    dst,
                    Expression::Constant(Constant::Float(ptr.resolve(&code.floats)))
                );
            }
            Opcode::Bool { dst, value } => {
                push_expr!(i, dst, Expression::Constant(Constant::Bool(value.0)));
            }
            Opcode::String { dst, ptr } => {
                push_expr!(
                    i,
                    dst,
                    Expression::Constant(Constant::String(ptr.resolve(&code.strings).to_owned()))
                );
            }
            Opcode::GetGlobal { dst, global } => {
                if f.regtype(dst).0 == 13 {
                    push_expr!(
                        i,
                        dst,
                        Expression::Constant(Constant::String(
                            global_value_from_constant(code, global).unwrap()
                        ))
                    );
                }
            }
            Opcode::Add { dst, a, b } => {
                push_expr!(i, dst, add(expr!(a), expr!(b)));
            }
            Opcode::Sub { dst, a, b } => {
                push_expr!(i, dst, sub(expr!(a), expr!(b)));
            }
            Opcode::Decr { dst } => {
                push_expr!(i, dst, decr(expr!(dst)));
            }
            Opcode::Incr { dst } => {
                push_expr!(i, dst, incr(expr!(dst)));
            }
            Opcode::Mov { dst, src } => {
                push_expr!(i, dst, expr!(src));
            }
            Opcode::New { dst } => {
                // Constructor analysis
                constructor_ctx = Some((dst, i));
            }
            Opcode::Call0 { dst, fun } => {
                push_expr!(i, dst, Expression::Call(fun, Vec::new()));
            }
            Opcode::Call1 { dst, fun, arg0 } => {
                if let Some((new, j)) = constructor_ctx {
                    if new == arg0 {
                        push_expr!(
                            j,
                            new,
                            Expression::Constructor(ConstructorCall::new(
                                f.regtype(new),
                                Vec::new()
                            ))
                        );
                    }
                } else {
                    push_expr!(i, dst, Expression::Call(fun, make_args!(arg0)));
                }
            }
            Opcode::Call2 {
                dst,
                fun,
                arg0,
                arg1,
            } => {
                if let Some((new, j)) = constructor_ctx {
                    if new == arg0 {
                        push_expr!(
                            j,
                            new,
                            Expression::Constructor(ConstructorCall::new(
                                f.regtype(new),
                                make_args!(arg1)
                            ))
                        );
                    }
                } else {
                    push_expr!(i, dst, Expression::Call(fun, make_args!(arg0, &arg1)));
                }
            }
            Opcode::Call3 {
                dst,
                fun,
                arg0,
                arg1,
                arg2,
            } => {
                if let Some((new, j)) = constructor_ctx {
                    if new == arg0 {
                        push_expr!(
                            j,
                            new,
                            Expression::Constructor(ConstructorCall::new(
                                f.regtype(new),
                                make_args!(arg1, arg2)
                            ))
                        );
                    }
                } else {
                    push_expr!(i, dst, Expression::Call(fun, make_args!(arg0, arg1, arg2)));
                }
            }
            Opcode::Ret { ret } => {
                // Do not display return void; only in case of an early return
                if scopes.has_some() {
                    statement = Some(if f.regtype(ret).is_void() {
                        Statement::ReturnVoid
                    } else {
                        Statement::Return { expr: expr!(ret) }
                    });
                } else if !f.regtype(ret).is_void() {
                    statement = Some(Statement::Return { expr: expr!(ret) });
                }
            }
            Opcode::Label => scopes.push_scope(Scope::new(ScopeType::Loop(LoopScope::new()))),
            Opcode::JAlways { offset } => {
                if offset < 0 {
                    // It's the jump back of a loop
                    if let Some((loop_, stmts)) = scopes.pop_last_loop() {
                        if let Some(cond) = loop_.cond {
                            statement = Some(Statement::While { cond, stmts });
                        } else {
                            statement = Some(Statement::While {
                                cond: constant_bool(true),
                                stmts,
                            });
                        }
                    }
                } else {
                    // It's the jump over of an else clause
                    scopes.push_scope(Scope::new(ScopeType::Else { len: offset + 1 }));
                }
            }
            Opcode::JFalse { cond, offset } => {
                if offset > 0 {
                    // while (true)
                    if matches!(f.ops[i + offset as usize], Opcode::JAlways { .. }) {
                        if let ScopeType::Loop(loop_) = &mut scopes.last_mut().ty {
                            loop_.cond = Some(expr!(cond));
                        }
                    } else {
                        scopes.push_scope(Scope::new(ScopeType::Branch {
                            len: offset + 1,
                            cond: expr!(cond),
                        }));
                    }
                    //println!("Increase nesting !");
                }
            }
            Opcode::JTrue { cond, offset } => {
                if offset > 0 {
                    scopes.push_scope(Scope::new(ScopeType::Branch {
                        len: offset + 1,
                        cond: not(expr!(cond)),
                    }));
                }
            }
            Opcode::JSGte { a, b, offset } => {
                if offset > 0 {
                    // It's a loop
                    if matches!(f.ops[i + offset as usize], Opcode::JAlways { offset } if offset < 0)
                    {
                        if let ScopeType::Loop(loop_) = &mut scopes.last_mut().ty {
                            loop_.cond = Some(not(gte(expr!(a), expr!(b))));
                        }
                    } else {
                        // It's an if
                        scopes.push_scope(Scope::new(ScopeType::Branch {
                            len: offset + 1,
                            cond: not(gte(expr!(a), expr!(b))),
                        }));
                    }
                }
            }
            _ => {}
        }

        // Pass trough all scopes and find which ones should finish
        scopes.push_stmt(statement.take());
    }

    if scopes.depth() != 1 {
        println!("Wait a minute, not all scopes have finished");
    }

    scopes.statements()
}

fn global_value_from_constant(code: &Bytecode, global: RefGlobal) -> Option<String> {
    code.globals_initializers.get(&global).and_then(|&x| {
        code.constants
            .as_ref()
            .map(|constants| code.strings[constants[x].fields[0]].to_owned())
    })
}
