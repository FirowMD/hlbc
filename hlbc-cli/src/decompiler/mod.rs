//! The decompiler used to get haxe sources back from the bytecode definitions.
//! More info on how everything works in the wiki : [https://github.com/Gui-Yom/hlbc/wiki/Decompilation]

use std::collections::{HashMap, HashSet};
use std::fmt::Write;

use hlbc::opcodes::Opcode;
use hlbc::types::{Function, RefField, RefGlobal, Reg, Type, TypeObj};
use hlbc::Bytecode;

use crate::decompiler::ast::{
    add, call, call_fun, cst_bool, cst_float, cst_int, cst_null, cst_string, cst_this, decr, eq,
    gt, gte, incr, lt, lte, not, noteq, sub, Call, ConstructorCall, Expr, LoopScope, Scope,
    ScopeType, Scopes, Statement,
};

/// A simple representation for the Haxe source code generated by the decompiler
mod ast;
/// Functions to render the [ast] to a string
mod fmt;

pub struct FormatOptions {
    indent: String,
    inc_indent: String,
}

impl FormatOptions {
    pub fn new(inc_indent: &str) -> Self {
        Self {
            indent: String::new(),
            inc_indent: inc_indent.to_string(),
        }
    }

    pub fn with_base_indent(indent: &str, inc_indent: &str) -> Self {
        Self {
            indent: indent.to_string(),
            inc_indent: inc_indent.to_string(),
        }
    }

    pub fn inc_nesting(&self) -> Self {
        FormatOptions {
            indent: format!("{}{}", self.indent, self.inc_indent),
            inc_indent: self.inc_indent.clone(),
        }
    }
}

pub fn decompile_class(code: &Bytecode, obj: &TypeObj) -> String {
    let mut buf = String::with_capacity(1024);

    let mut is_static = false;
    writeln!(
        &mut buf,
        "class {} {}{{",
        obj.name.display(code),
        if let Some(e) = obj.super_ {
            is_static = e.0 == 12;
            format!("extends {} ", e.display(code))
        } else {
            "".to_string()
        }
    )
    .unwrap();
    let indent = FormatOptions {
        indent: String::new(),
        inc_indent: "  ".to_string(),
    };
    for (i, f) in obj
        .fields
        .iter()
        .enumerate()
        .skip(obj.fields.len() - obj.own_fields.len())
    {
        if obj.bindings.get(&RefField(i)).is_some() {
            continue;
        }
        writeln!(
            &mut buf,
            "{indent}{}var {}: {}",
            if is_static { "static " } else { "" },
            f.name.display(code),
            f.t.display(code)
        )
        .unwrap();
    }
    writeln!(&mut buf, "// BINDINGS").unwrap();

    for fun in obj.bindings.values() {
        //let fi = &obj.fields[fi.0];
        let fun = fun.resolve_as_fn(code).unwrap();
        writeln!(
            &mut buf,
            "{indent}{}{}{}{indent}}}\n",
            if is_static { "static " } else { "" },
            decompile_function_header(code, fun),
            decompile_function_body(code, &indent.inc_nesting(), fun)
        )
        .unwrap();
    }

    writeln!(&mut buf, "// METHODS").unwrap();

    for f in &obj.protos {
        let f = f.findex.resolve_as_fn(code).unwrap();
        writeln!(
            &mut buf,
            "{indent}{}{}{indent}}}\n",
            decompile_function_header(code, f),
            decompile_function_body(code, &indent.inc_nesting(), f)
        )
        .unwrap();
    }
    writeln!(&mut buf, "}}").unwrap();
    buf
}

pub fn decompile_function_header(code: &Bytecode, f: &Function) -> String {
    let mut buf = String::with_capacity(256);

    write!(&mut buf, "function {}(", f.name.unwrap().display(code)).unwrap();

    match f.t.resolve(&code.types) {
        Type::Fun(fun) => {
            // Skip the first because its a method (this)
            for (i, a) in fun.args.iter().enumerate().skip(1) {
                if i != 1 {
                    write!(&mut buf, ", ").unwrap();
                }
                write!(&mut buf, "reg{}: {}", i, a.display(code)).unwrap();
            }
            writeln!(
                &mut buf,
                "): {} {{ // {}",
                fun.ret.display(code),
                f.findex.0
            )
            .unwrap();
        }
        _ => {
            unreachable!()
        }
    }
    buf
}

pub fn decompile_closure(code: &Bytecode, indent: &FormatOptions, f: &Function) -> String {
    let mut buf = String::with_capacity(256);

    write!(&mut buf, "(").unwrap();

    match f.t.resolve(&code.types) {
        Type::Fun(fun) => {
            // Skip the first because its a method (this)
            for (i, a) in fun.args.iter().enumerate().skip(1) {
                if i != 1 {
                    write!(&mut buf, ", ").unwrap();
                }
                write!(&mut buf, "reg{}: {}", i, a.display(code)).unwrap();
            }
            writeln!(&mut buf, ") -> {{ // {}", f.findex.0).unwrap();
        }
        _ => {
            unreachable!()
        }
    }
    write!(
        &mut buf,
        "{}",
        decompile_function_body(code, &indent.inc_nesting(), f)
    )
    .unwrap();

    writeln!(&mut buf, "{indent}}}").unwrap();
    buf
}

pub fn decompile_function_body(code: &Bytecode, indent: &FormatOptions, f: &Function) -> String {
    let mut buf = String::with_capacity(256);

    for a in f
        .assigns
        .as_ref()
        .unwrap()
        .iter()
        .map(|(s, i)| format!("{} at opcode {}", s.resolve(&code.strings), i - 1))
    {
        writeln!(&mut buf, "{indent}{a}").unwrap();
    }
    writeln!(&mut buf).unwrap();

    for stmt in make_statements(code, f) {
        stmt.display(&mut buf, indent, code, f).unwrap();
    }

    buf
}

fn make_statements(code: &Bytecode, f: &Function) -> Vec<Statement> {
    // Holds the statements, handles the scopes
    let mut scopes = Scopes::new();
    // Current iteration statement, to be pushed onto the finished statements or the nesting
    let mut statement = None;
    // Expression values for each registers
    let mut reg_state = HashMap::with_capacity(f.regs.len());
    // Some when we're parsing a constructor call (between New and Call)
    let mut constructor_ctx = None;
    // Variable names we already declared
    let mut seen = HashSet::new();

    // Initialize register state with the function arguments
    for i in 0..f.ty(code).args.len() {
        reg_state.insert(
            Reg(i as u32),
            Expr::Variable(Reg(i as u32), f.arg_name(code, i)),
        );
    }

    // Create a statement and update the register state (depending on inline rules)
    macro_rules! push_expr {
        ($i:expr, $dst:expr, $e:expr) => {
            let name = f.var_name(code, $i);
            let expr = $e;
            // Inline check
            if name.is_none() {
                reg_state.insert($dst, expr);
            } else {
                reg_state.insert($dst, Expr::Variable($dst, name.clone()));
                statement = Some(Statement::Assign {
                    declaration: seen.insert(name.clone().unwrap()),
                    reg: $dst,
                    name,
                    assign: expr,
                });
            }
        };
    }

    // Get the expr for a register
    macro_rules! expr {
        ($reg:expr) => {
            reg_state.get(&$reg).expect("No expr for reg ?").clone()
        };
    }

    // Crate a Vec<Expression> for a list of args
    macro_rules! make_args {
        ($($arg:expr),* $(,)?) => {
            vec![$(expr!($arg)),*]
        }
    }

    macro_rules! push_call {
        ($i:ident, $dst:ident, $fun:ident, $arg0:expr $(, $args:expr)*) => {
            if let Some((new, j)) = constructor_ctx {
                if new == $arg0 {
                    push_expr!(
                        j,
                        new,
                        Expr::Constructor(ConstructorCall::new(f.regtype(new), make_args!($($args),*)))
                    );
                    constructor_ctx = None;
                }
            } else {
                if let Some(parent) = $fun.resolve_as_fn(code).unwrap().parent {
                    if parent == f.regtype($arg0) {
                        push_expr!($i, $dst, call(Expr::Field(Box::new(expr!($arg0)), $fun.resolve_as_fn(code).unwrap().name.clone().unwrap().resolve(&code.strings).to_owned()), make_args!($($args),*)));
                    } else {
                        push_expr!($i, $dst, call_fun($fun, make_args!($arg0 $(, $args)*)));
                    }
                } else {
                    push_expr!($i, $dst, call_fun($fun, make_args!($arg0 $(, $args)*)));
                }
            }
        };
    }

    macro_rules! push_callN {
        ($i:ident, $dst:expr, $fun:expr, $args:expr) => {
            if let Some((new, j)) = constructor_ctx {
                if new == $args[0] {
                    push_expr!(
                        j,
                        new,
                        Expr::Constructor(ConstructorCall::new(
                            f.regtype(new),
                            $args[1..].iter().map(|x| expr!(x)).collect::<Vec<_>>()
                        ))
                    );
                }
            } else {
                push_expr!(
                    $i,
                    $dst,
                    call_fun($fun, $args.iter().map(|x| expr!(x)).collect::<Vec<_>>())
                );
            }
        };
    }

    // Process a jmp instruction, might be the exit condition of a loop or an if
    macro_rules! push_jmp {
        ($i:ident, $offset:ident, $cond:expr) => {
            if $offset > 0 {
                // It's a loop
                if matches!(f.ops[$i + $offset as usize], Opcode::JAlways { offset } if offset < 0) {
                    if let ScopeType::Loop(loop_) = &mut scopes.last_mut().ty {
                        loop_.cond = Some($cond);
                    }
                } else {
                    // It's an if
                    scopes.push_scope(Scope::new(ScopeType::Branch {
                        len: $offset + 1,
                        cond: $cond,
                    }));
                }
            }
        }
    }

    let iter = f.ops.iter().enumerate();
    for (i, o) in iter {
        //println!("ITER");
        match o {
            &Opcode::Int { dst, ptr } => {
                push_expr!(i, dst, cst_int(ptr.resolve(&code.ints)));
            }
            &Opcode::Float { dst, ptr } => {
                push_expr!(i, dst, cst_float(ptr.resolve(&code.floats)));
            }
            &Opcode::Bool { dst, value } => {
                push_expr!(i, dst, cst_bool(value.0));
            }
            &Opcode::String { dst, ptr } => {
                push_expr!(i, dst, cst_string(ptr.resolve(&code.strings).to_owned()));
            }
            &Opcode::GetGlobal { dst, global } => {
                if f.regtype(dst).0 == 13 {
                    push_expr!(
                        i,
                        dst,
                        cst_string(global_value_from_constant(code, global).unwrap())
                    );
                }
                // TODO handle other global types
            }
            &Opcode::Add { dst, a, b } => {
                push_expr!(i, dst, add(expr!(a), expr!(b)));
            }
            &Opcode::Sub { dst, a, b } => {
                push_expr!(i, dst, sub(expr!(a), expr!(b)));
            }
            &Opcode::Decr { dst } => {
                push_expr!(i, dst, decr(expr!(dst)));
            }
            &Opcode::Incr { dst } => {
                push_expr!(i, dst, incr(expr!(dst)));
            }
            &Opcode::Mov { dst, src } => {
                push_expr!(i, dst, expr!(src));
            }
            &Opcode::New { dst } => {
                // Constructor analysis
                constructor_ctx = Some((dst, i));
            }
            &Opcode::Call0 { dst, fun } => {
                push_expr!(i, dst, call_fun(fun, Vec::new()));
            }
            &Opcode::Call1 { dst, fun, arg0 } => {
                push_call!(i, dst, fun, arg0)
            }
            &Opcode::Call2 {
                dst,
                fun,
                arg0,
                arg1,
            } => {
                push_call!(i, dst, fun, arg0, arg1)
            }
            &Opcode::Call3 {
                dst,
                fun,
                arg0,
                arg1,
                arg2,
            } => {
                push_call!(i, dst, fun, arg0, arg1, arg2)
            }
            &Opcode::Call4 {
                dst,
                fun,
                arg0,
                arg1,
                arg2,
                arg3,
            } => {
                push_call!(i, dst, fun, arg0, arg1, arg2, arg3)
            }
            Opcode::CallN { dst, fun, args } => {
                push_callN!(i, *dst, *fun, args)
            }
            Opcode::CallMethod { dst, field, args } => {
                push_expr!(
                    i,
                    *dst,
                    call(
                        Expr::Field(
                            Box::new(expr!(args[0])),
                            field
                                .display_obj(f.regtype(args[0]).resolve(&code.types), code)
                                .to_string()
                        ),
                        args.iter().skip(1).map(|x| expr!(x)).collect::<Vec<_>>()
                    )
                );
            }
            Opcode::CallThis { dst, field, args } => {
                push_expr!(
                    i,
                    *dst,
                    call(
                        Expr::Field(
                            Box::new(cst_this()),
                            field
                                .display_obj(f.regtype(args[0]).resolve(&code.types), code)
                                .to_string()
                        ),
                        args.iter().skip(1).map(|x| expr!(x)).collect::<Vec<_>>()
                    )
                );
            }
            &Opcode::Ret { ret } => {
                // Do not display return void; only in case of an early return
                if scopes.depth() > 1 {
                    statement = Some(if f.regtype(ret).is_void() {
                        Statement::ReturnVoid
                    } else {
                        Statement::Return(expr!(ret))
                    });
                } else if !f.regtype(ret).is_void() {
                    statement = Some(Statement::Return(expr!(ret)));
                }
            }
            &Opcode::Label => scopes.push_scope(Scope::new(ScopeType::Loop(LoopScope::new()))),
            &Opcode::JAlways { offset } => {
                if offset < 0 {
                    // It's the jump back of a loop
                    if let Some((loop_, stmts)) = scopes.pop_last_loop() {
                        if let Some(cond) = loop_.cond {
                            statement = Some(Statement::While { cond, stmts });
                        } else {
                            statement = Some(Statement::While {
                                cond: cst_bool(true),
                                stmts,
                            });
                        }
                    }
                } else {
                    // It's the jump over of an else clause
                    scopes.push_scope(Scope::new(ScopeType::Else { len: offset + 1 }));
                }
            }
            &Opcode::JTrue { cond, offset } => {
                push_jmp!(i, offset, not(expr!(cond)))
            }
            &Opcode::JFalse { cond, offset } => {
                push_jmp!(i, offset, expr!(cond))
            }
            &Opcode::JNull { reg, offset } => {
                push_jmp!(i, offset, noteq(expr!(reg), cst_null()))
            }
            &Opcode::JNotNull { reg, offset } => {
                push_jmp!(i, offset, eq(expr!(reg), cst_null()))
            }
            &Opcode::JSGte { a, b, offset } | &Opcode::JUGte { a, b, offset } => {
                push_jmp!(i, offset, gt(expr!(b), expr!(a)))
            }
            &Opcode::JSGt { a, b, offset } => {
                push_jmp!(i, offset, gte(expr!(b), expr!(a)))
            }
            &Opcode::JSLte { a, b, offset } => {
                push_jmp!(i, offset, lt(expr!(b), expr!(a)))
            }
            &Opcode::JSLt { a, b, offset } | &Opcode::JULt { a, b, offset } => {
                push_jmp!(i, offset, lte(expr!(b), expr!(a)))
            }
            &Opcode::JEq { a, b, offset } => {
                push_jmp!(i, offset, noteq(expr!(a), expr!(b)))
            }
            &Opcode::JNotEq { a, b, offset } => {
                push_jmp!(i, offset, eq(expr!(a), expr!(b)))
            }
            _ => {}
        }

        // Pass trough all scopes and find which ones should finish
        scopes.push_stmt(statement.take());
    }

    if scopes.depth() != 1 {
        println!("Wait a minute, not all scopes have finished");
    }

    scopes.statements()
}

fn global_value_from_constant(code: &Bytecode, global: RefGlobal) -> Option<String> {
    code.globals_initializers.get(&global).and_then(|&x| {
        code.constants
            .as_ref()
            .map(|constants| code.strings[constants[x].fields[0]].to_owned())
    })
}
