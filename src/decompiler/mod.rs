//! The decompiler used to get haxe sources back from the bytecode definitions.
//! More info on how everything works in the [wiki](https://github.com/Gui-Yom/hlbc/wiki/Decompilation).
//!
//! The decompiler takes bytecode elements as input and outputs [ast] structures that can be displayed.

use std::collections::{HashMap, HashSet};

use ast::*;

use crate::types::{FunPtr, Function, RefField, Reg, Type, TypeObj};
use crate::Bytecode;
use crate::Opcode;

/// A simple representation for the Haxe source code generated by the decompiler
pub mod ast;
/// Functions to render the [ast] to a string
pub mod fmt;

/// Decompile a class with its static and instance fields and methods.
pub fn decompile_class(code: &Bytecode, obj: &TypeObj) -> Class {
    let static_type = obj.get_static_type(code);

    let mut fields = Vec::new();
    for (i, f) in obj.own_fields.iter().enumerate() {
        if obj
            .bindings
            .get(&RefField(i + obj.fields.len() - obj.own_fields.len()))
            .is_some()
        {
            continue;
        }
        fields.push(ClassField {
            name: f.name.display(code),
            static_: false,
            ty: f.t,
        });
    }
    if let Some(ty) = static_type {
        for (i, f) in ty.own_fields.iter().enumerate() {
            if ty
                .bindings
                .get(&RefField(i + ty.fields.len() - ty.own_fields.len()))
                .is_some()
            {
                continue;
            }
            fields.push(ClassField {
                name: f.name.display(code),
                static_: true,
                ty: f.t,
            });
        }
    }

    let mut methods = Vec::new();
    for fun in obj.bindings.values() {
        methods.push(Method {
            fun: *fun,
            static_: false,
            dynamic: true,
            statements: decompile_function(code, fun.resolve_as_fn(code).unwrap()),
        })
    }
    if let Some(ty) = static_type {
        for fun in ty.bindings.values() {
            methods.push(Method {
                fun: *fun,
                static_: true,
                dynamic: false,
                statements: decompile_function(code, fun.resolve_as_fn(code).unwrap()),
            })
        }
    }
    for f in &obj.protos {
        methods.push(Method {
            fun: f.findex,
            static_: false,
            dynamic: false,
            statements: decompile_function(code, f.findex.resolve_as_fn(code).unwrap()),
        })
    }

    Class {
        name: obj.name.resolve(&code.strings).to_owned(),
        parent: obj
            .super_
            .and_then(|ty| ty.resolve_as_obj(&code.types))
            .map(|ty| ty.name.display(code)),
        fields,
        methods,
    }
}

/// Helper to process a stack of scopes (branches, loops)
pub struct Scopes {
    // A linked list would be appreciable i think
    /// There is always at least one scope, the root scope
    scopes: Vec<Scope>,
}

impl Scopes {
    pub fn new() -> Self {
        Self {
            scopes: vec![Scope {
                ty: ScopeType::RootScope,
                stmts: Vec::new(),
            }],
        }
    }

    pub fn pop_last_loop(&mut self) -> Option<(LoopScope, Vec<Statement>)> {
        for idx in (0..self.depth()).rev() {
            let scope = self.scopes.remove(idx);
            match scope.ty {
                ScopeType::Loop(l) => {
                    return Some((l, scope.stmts));
                }
                _ => {
                    self.scopes.insert(idx, scope);
                }
            }
        }
        None
    }

    pub fn last_loop(&self) -> Option<&LoopScope> {
        for idx in (0..self.depth()).rev() {
            match &self.scopes[idx].ty {
                ScopeType::Loop(l) => {
                    return Some(l);
                }
                _ => {}
            }
        }
        None
    }

    pub fn last_mut(&mut self) -> &mut Scope {
        self.scopes.last_mut().unwrap()
    }

    pub fn push_scope(&mut self, scope: Scope) {
        self.scopes.push(scope);
    }

    pub fn depth(&self) -> usize {
        self.scopes.len()
    }

    pub fn push_stmt(&mut self, mut stmt: Option<Statement>) {
        // Start to iterate from the end ('for' because we need the index)
        for idx in (0..self.depth()).rev() {
            let mut scope = self.scopes.remove(idx);

            if let Some(stmt) = stmt.take() {
                scope.stmts.push(stmt);
            }

            // We only handle branches we know the length of
            // We can't know the end of a loop scope before seeing the jump back
            match scope.ty {
                ScopeType::Branch { mut len, cond } => {
                    // Decrease scope len
                    len -= 1;
                    if len <= 0 {
                        //println!("Decrease nesting {parent:?}");
                        stmt = Some(Statement::If {
                            cond,
                            stmts: scope.stmts,
                        });
                    } else {
                        // Scope continues
                        self.scopes.insert(
                            idx,
                            Scope {
                                ty: ScopeType::Branch { len, cond },
                                stmts: scope.stmts,
                            },
                        );
                    }
                }
                ScopeType::Else { mut len } => {
                    // Decrease scope len
                    len -= 1;
                    if len <= 0 {
                        //println!("Decrease nesting {parent:?}");
                        stmt = Some(Statement::Else { stmts: scope.stmts });
                    } else {
                        // Scope continues
                        self.scopes.insert(
                            idx,
                            Scope {
                                ty: ScopeType::Else { len },
                                stmts: scope.stmts,
                            },
                        );
                    }
                }
                _ => {
                    self.scopes.insert(idx, scope);
                }
            }
        }
        if let Some(stmt) = stmt.take() {
            self.last_mut().stmts.push(stmt);
        }
    }

    pub fn statements(mut self) -> Vec<Statement> {
        self.scopes.pop().unwrap().stmts
    }
}

pub struct Scope {
    pub ty: ScopeType,
    pub stmts: Vec<Statement>,
}

impl Scope {
    pub fn new(ty: ScopeType) -> Self {
        Self {
            ty,
            stmts: Vec::new(),
        }
    }
}

pub enum ScopeType {
    RootScope,
    Branch { len: i32, cond: Expr },
    Else { len: i32 },
    Loop(LoopScope),
}

pub struct LoopScope {
    pub cond: Option<Expr>,
    pub start: usize,
}

impl LoopScope {
    pub fn new(start: usize) -> Self {
        Self { cond: None, start }
    }
}

enum ExprCtx {
    Constructor {
        reg: Reg,
        pos: usize,
    },
    Anonymous {
        pos: usize,
        fields: HashMap<RefField, Expr>,
        remaining: usize,
    },
}

/// Decompile a function to a list of [Statement]s.
/// This works by analyzing each opcodes in order while trying to construct contexts and intents.
pub fn decompile_function(code: &Bytecode, f: &Function) -> Vec<Statement> {
    // Scope stack, holds the statements
    let mut scopes = Scopes::new();
    // Current iteration statement, to be pushed onto the finished statements or the nesting
    let mut statement = None;
    // Expression values for each registers
    let mut reg_state = HashMap::with_capacity(f.regs.len());
    // For parsing statements made of multiple instructions like constructor calls and anonymous structures
    let mut expr_ctx = Vec::new();
    // Variable names we already declared
    let mut seen = HashSet::new();

    let mut start = 0;
    // First argument / First register is 'this'
    if f.is_method()
        || f.name
            .map(|n| n.resolve(&code.strings) == "__constructor__")
            .unwrap_or(false)
    {
        reg_state.insert(Reg(0), cst_this());
        start = 1;
    }

    // Initialize register state with the function arguments
    for i in start..f.ty(code).args.len() {
        reg_state.insert(
            Reg(i as u32),
            Expr::Variable(
                Reg(i as u32),
                f.arg_name(code, i - start).map(ToOwned::to_owned),
            ),
        );
    }

    macro_rules! push_stmt {
        ($stmt:expr) => {
            statement = Some($stmt);
        };
    }

    // Update the register state and create a statement depending on inline rules
    macro_rules! push_expr {
        ($i:expr, $dst:expr, $e:expr) => {
            let name = f.var_name(code, $i);
            let expr = $e;
            // Inline check
            if name.is_none() {
                reg_state.insert($dst, expr);
            } else {
                reg_state.insert($dst, Expr::Variable($dst, name.clone()));
                push_stmt!(Statement::Assign {
                    declaration: seen.insert(name.clone().unwrap()),
                    variable: Expr::Variable($dst, name),
                    assign: expr,
                });
            }
        };
    }

    let missing_expr = || Expr::Unknown("missing expr".to_owned());

    // Get the expr for a register
    macro_rules! expr {
        ($reg:expr) => {
            reg_state.get(&$reg).cloned().unwrap_or_else(missing_expr)
        };
    }

    // Crate a Vec<Expression> for a list of args
    macro_rules! make_args {
        ($($arg:expr),* $(,)?) => {
            vec![$(expr!($arg)),*]
        }
    }

    macro_rules! push_call {
        ($i:ident, $dst:ident, $fun:ident, $arg0:expr $(, $args:expr)*) => {
            if let Some(&ExprCtx::Constructor { reg, pos }) = expr_ctx.last() {
                if reg == $arg0 {
                    push_expr!(
                        pos,
                        reg,
                        Expr::Constructor(ConstructorCall::new(f.regtype(reg), make_args!($($args),*)))
                    );
                    expr_ctx.pop();
                }
            } else {
                match $fun.resolve(code) {
                    FunPtr::Fun(func) => {
                        let call = if func.is_method() {
                            Call::new(Expr::Field(Box::new(expr!($arg0)), func.name.clone().unwrap().resolve(&code.strings).to_owned()), make_args!($($args),*))
                        } else {
                            Call::new_fun($fun, make_args!($arg0 $(, $args)*))
                        };
                        if func.ty(code).ret.is_void() {
                            push_stmt!(Statement::Call(call));
                        } else {
                            push_expr!($i, $dst, Expr::Call(Box::new(call)));
                        }
                    }
                    FunPtr::Native(n) => {
                        let call = Call::new_fun($fun, make_args!($arg0 $(, $args)*));
                        if n.ty(code).ret.is_void() {
                            push_stmt!(Statement::Call(call));
                        } else {
                            push_expr!($i, $dst, Expr::Call(Box::new(call)));
                        }
                    }
                }
            }
        };
    }

    // Process a jmp instruction, might be the exit condition of a loop or an if
    macro_rules! push_jmp {
        ($i:ident, $offset:ident, $cond:expr) => {
            if $offset > 0 {
                // It's a loop
                if matches!(f.ops[$i + $offset as usize], Opcode::JAlways { offset } if offset < 0) {
                    if let ScopeType::Loop(loop_) = &mut scopes.last_mut().ty {
                        if loop_.cond.is_none() {
                            loop_.cond = Some($cond);
                        } else {
                            scopes.push_scope(Scope::new(ScopeType::Branch {
                                len: $offset + 1,
                                cond: $cond,
                            }));
                        }
                    } else {
                        scopes.push_scope(Scope::new(ScopeType::Branch {
                            len: $offset + 1,
                            cond: $cond,
                        }));
                    }
                } else {
                    // It's an if
                    scopes.push_scope(Scope::new(ScopeType::Branch {
                        len: $offset + 1,
                        cond: $cond,
                    }));
                }
            }
        }
    }

    let iter = f.ops.iter().enumerate();
    for (i, o) in iter {
        // Opcodes are in semantic order
        match o {
            //region CONSTANTS
            &Opcode::Int { dst, ptr } => {
                push_expr!(i, dst, cst_int(ptr.resolve(&code.ints)));
            }
            &Opcode::Float { dst, ptr } => {
                push_expr!(i, dst, cst_float(ptr.resolve(&code.floats)));
            }
            &Opcode::Bool { dst, value } => {
                push_expr!(i, dst, cst_bool(value.0));
            }
            &Opcode::String { dst, ptr } => {
                push_expr!(i, dst, cst_string(ptr.resolve(&code.strings).to_owned()));
            }
            &Opcode::Null { dst } => {
                push_expr!(i, dst, cst_null());
            }
            //endregion

            //region OPERATORS
            &Opcode::Mov { dst, src } => {
                push_expr!(i, dst, expr!(src));
                // Workaround for when the instructions after this one use dst and src interchangeably.
                reg_state.insert(src, Expr::Variable(dst, f.var_name(code, i)));
            }
            &Opcode::Add { dst, a, b } => {
                push_expr!(i, dst, add(expr!(a), expr!(b)));
            }
            &Opcode::Sub { dst, a, b } => {
                push_expr!(i, dst, sub(expr!(a), expr!(b)));
            }
            &Opcode::Mul { dst, a, b } => {
                push_expr!(i, dst, mul(expr!(a), expr!(b)));
            }
            &Opcode::Shl { dst, a, b } => {
                push_expr!(i, dst, shl(expr!(a), expr!(b)));
            }
            &Opcode::SShr { dst, a, b } | &Opcode::UShr { dst, a, b } => {
                push_expr!(i, dst, shr(expr!(a), expr!(b)));
            }
            &Opcode::And { dst, a, b } => {
                push_expr!(i, dst, and(expr!(a), expr!(b)));
            }
            &Opcode::Or { dst, a, b } => {
                push_expr!(i, dst, or(expr!(a), expr!(b)));
            }
            &Opcode::Xor { dst, a, b } => {
                push_expr!(i, dst, xor(expr!(a), expr!(b)));
            }
            &Opcode::Neg { dst, src } => {
                push_expr!(i, dst, neg(expr!(src)));
            }
            &Opcode::Not { dst, src } => {
                push_expr!(i, dst, not(expr!(src)));
            }
            &Opcode::Incr { dst } => {
                push_expr!(i, dst, incr(expr!(dst)));
            }
            &Opcode::Decr { dst } => {
                push_expr!(i, dst, decr(expr!(dst)));
            }
            //endregion

            //region CALLS
            &Opcode::Call0 { dst, fun } => {
                if fun.ty(code).ret.is_void() {
                    push_stmt!(Statement::Call(Call::new_fun(fun, Vec::new())));
                } else {
                    push_expr!(i, dst, call_fun(fun, Vec::new()));
                }
            }
            &Opcode::Call1 { dst, fun, arg0 } => {
                push_call!(i, dst, fun, arg0)
            }
            &Opcode::Call2 {
                dst,
                fun,
                arg0,
                arg1,
            } => {
                push_call!(i, dst, fun, arg0, arg1)
            }
            &Opcode::Call3 {
                dst,
                fun,
                arg0,
                arg1,
                arg2,
            } => {
                push_call!(i, dst, fun, arg0, arg1, arg2)
            }
            &Opcode::Call4 {
                dst,
                fun,
                arg0,
                arg1,
                arg2,
                arg3,
            } => {
                push_call!(i, dst, fun, arg0, arg1, arg2, arg3)
            }
            Opcode::CallN { dst, fun, args } => {
                if let Some(&ExprCtx::Constructor { reg, pos }) = expr_ctx.last() {
                    if reg == args[0] {
                        push_expr!(
                            pos,
                            reg,
                            Expr::Constructor(ConstructorCall::new(
                                f.regtype(reg),
                                args[1..].iter().map(|x| expr!(x)).collect::<Vec<_>>()
                            ))
                        );
                    }
                } else if fun.resolve_as_fn(code).unwrap().ty(code).ret.is_void() {
                    push_stmt!(Statement::Call(Call::new_fun(
                        *fun,
                        args.iter().map(|x| expr!(x)).collect::<Vec<_>>(),
                    )));
                } else {
                    push_expr!(
                        i,
                        *dst,
                        call_fun(*fun, args.iter().map(|x| expr!(x)).collect::<Vec<_>>())
                    );
                }
            }
            Opcode::CallMethod { dst, field, args } => {
                let method = f.regtype(args[0]).method(field.0, code).unwrap();
                let call = Call::new(
                    Expr::Field(
                        Box::new(expr!(args[0])),
                        method.name.resolve(&code.strings).to_owned(),
                    ),
                    args.iter().skip(1).map(|x| expr!(x)).collect::<Vec<_>>(),
                );
                if method
                    .findex
                    .resolve_as_fn(code)
                    .map(|fun| fun.ty(code).ret.is_void())
                    .unwrap_or(false)
                {
                    push_stmt!(Statement::Call(call));
                } else {
                    push_expr!(i, *dst, Expr::Call(Box::new(call)));
                }
            }
            Opcode::CallThis { dst, field, args } => {
                let method = f.regs[0].method(field.0, code).unwrap();
                let call = Call::new(
                    Expr::Field(
                        Box::new(cst_this()),
                        method.name.resolve(&code.strings).to_owned(),
                    ),
                    args.iter().map(|x| expr!(x)).collect::<Vec<_>>(),
                );
                if method
                    .findex
                    .resolve_as_fn(code)
                    .map(|fun| fun.ty(code).ret.is_void())
                    .unwrap_or(false)
                {
                    push_stmt!(Statement::Call(call));
                } else {
                    push_expr!(i, *dst, Expr::Call(Box::new(call)));
                }
            }
            Opcode::CallClosure { dst, fun, args } => {
                let call = Call::new(
                    expr!(*fun),
                    args.iter().map(|x| expr!(x)).collect::<Vec<_>>(),
                );
                if f.regtype(*fun)
                    .resolve_as_fun(&code.types)
                    .unwrap()
                    .ret
                    .is_void()
                {
                    push_stmt!(Statement::Call(call));
                } else {
                    push_expr!(i, *dst, Expr::Call(Box::new(call)));
                }
            }
            //endregion

            //region CLOSURES
            &Opcode::StaticClosure { dst, fun } => {
                push_expr!(
                    i,
                    dst,
                    Expr::Closure(
                        fun,
                        decompile_function(code, fun.resolve_as_fn(code).unwrap())
                    )
                );
            }
            &Opcode::InstanceClosure { dst, obj, fun } => {
                push_expr!(
                    i,
                    dst,
                    Expr::Field(
                        Box::new(expr!(obj)),
                        fun.resolve_as_fn(code)
                            .unwrap()
                            .name(code)
                            .unwrap_or("_")
                            .to_owned(),
                    )
                );
            }
            //endregion

            //region ACCESSES
            &Opcode::GetGlobal { dst, global } => {
                // Is a string
                if f.regtype(dst).0 == 13 {
                    push_expr!(
                        i,
                        dst,
                        cst_string(
                            code.globals_initializers
                                .get(&global)
                                .and_then(|&x| {
                                    code.constants.as_ref().map(|constants| {
                                        code.strings[constants[x].fields[0]].to_owned()
                                    })
                                })
                                .unwrap()
                        )
                    );
                } else {
                    match f.regtype(dst).resolve(&code.types) {
                        Type::Obj(obj) | Type::Struct(obj) => {
                            push_expr!(i, dst, Expr::Variable(dst, Some(obj.name.display(code))));
                        }
                        Type::Enum { global: eg, .. } => {
                            push_expr!(i, dst, Expr::Unknown("unknown enum variant".to_owned()));
                        }
                        _ => {}
                    }
                }
            }
            &Opcode::Field { dst, obj, field } => {
                push_expr!(i, dst, ast::field(expr!(obj), f.regtype(obj), field, code));
            }
            &Opcode::SetField { obj, field, src } => {
                let ctx = expr_ctx.pop();
                // Might be a SetField for an anonymous structure
                if let Some(ExprCtx::Anonymous {
                    pos,
                    mut fields,
                    mut remaining,
                }) = ctx
                {
                    fields.insert(field, expr!(src));
                    remaining -= 1;
                    // If we filled all the structure fields, we emit an expr
                    if remaining == 0 {
                        push_expr!(pos, obj, Expr::Anonymous(f.regtype(obj), fields));
                    } else {
                        expr_ctx.push(ExprCtx::Anonymous {
                            pos,
                            fields,
                            remaining,
                        });
                    }
                } else if let Some(ctx) = ctx {
                    expr_ctx.push(ctx);
                } else {
                    // Otherwise this is just a normal field set
                    push_stmt!(Statement::Assign {
                        declaration: false,
                        variable: ast::field(expr!(obj), f.regtype(obj), field, code),
                        assign: expr!(src),
                    });
                }
            }
            &Opcode::GetThis { dst, field } => {
                push_expr!(i, dst, ast::field(cst_this(), f.regs[0], field, code));
            }
            &Opcode::SetThis { field, src } => {
                push_stmt!(Statement::Assign {
                    declaration: false,
                    variable: ast::field(cst_this(), f.regs[0], field, code),
                    assign: expr!(src),
                });
            }
            &Opcode::DynGet { dst, obj, field } => {
                // TODO dyn get
            }
            &Opcode::DynSet { obj, field, src } => {
                // TODO dyn set
            }
            &Opcode::EnumIndex { dst, value } => {
                // TODO get enum variant
            }
            &Opcode::EnumField {
                dst,
                value,
                construct,
                field,
            } => {
                // TODO get enum field
            }
            &Opcode::SetEnumField { value, field, src } => {
                // TODO set enum field
            }
            //endregion

            //region CONTROL FLOW
            &Opcode::JTrue { cond, offset } => {
                push_jmp!(i, offset, not(expr!(cond)))
            }
            &Opcode::JFalse { cond, offset } => {
                push_jmp!(i, offset, expr!(cond))
            }
            &Opcode::JNull { reg, offset } => {
                push_jmp!(i, offset, noteq(expr!(reg), cst_null()))
            }
            &Opcode::JNotNull { reg, offset } => {
                push_jmp!(i, offset, eq(expr!(reg), cst_null()))
            }
            &Opcode::JSGte { a, b, offset } | &Opcode::JUGte { a, b, offset } => {
                push_jmp!(i, offset, gt(expr!(b), expr!(a)))
            }
            &Opcode::JSGt { a, b, offset } => {
                push_jmp!(i, offset, gte(expr!(b), expr!(a)))
            }
            &Opcode::JSLte { a, b, offset } => {
                push_jmp!(i, offset, lt(expr!(b), expr!(a)))
            }
            &Opcode::JSLt { a, b, offset } | &Opcode::JULt { a, b, offset } => {
                push_jmp!(i, offset, lte(expr!(b), expr!(a)))
            }
            &Opcode::JEq { a, b, offset } => {
                push_jmp!(i, offset, noteq(expr!(a), expr!(b)))
            }
            &Opcode::JNotEq { a, b, offset } => {
                push_jmp!(i, offset, eq(expr!(a), expr!(b)))
            }
            &Opcode::JAlways { offset } => {
                if offset < 0 {
                    println!("opcode {i}");
                    // It's either the jump backward of a loop or a continue statement
                    let loop_ = scopes.last_loop().unwrap();
                    // Scan the next instructions in order to find another jump to the same place
                    if f.ops.iter().enumerate().skip(i + 1).find_map(|(j, o)| {
                        // We found another jump to the same place !
                        if matches!(o, Opcode::JAlways {offset} if (j as i32 + offset + 1) as usize == loop_.start) {
                            Some(true)
                        } else {
                            None
                        }
                    }).unwrap_or(false) {
                        // If this jump is not the last jump backward for the current loop,
                        // It's definitely a continue; statement
                        push_stmt!(Statement::Continue);
                    } else {
                        let (loop_, stmts) = scopes.pop_last_loop().unwrap();
                        // It's the last jump backward of the loop, we generate the loop statement
                        if let Some(cond) = loop_.cond {
                            push_stmt!(Statement::While { cond, stmts });
                        } else {
                            push_stmt!(Statement::While {
                                cond: cst_bool(true),
                                stmts
                            });
                        }
                    }
                } else {
                    // Check the instruction just before the jump target
                    // If it's a jump backward of a loop
                    if matches!(f.ops[(i as i32 + offset) as usize], Opcode::JAlways {offset} if offset < 0)
                    {
                        // It's a break condition
                        push_stmt!(Statement::Break);
                    } else {
                        // It's the jump over of an else clause
                        scopes.push_scope(Scope::new(ScopeType::Else { len: offset + 1 }));
                    }
                }
            }
            &Opcode::Label => scopes.push_scope(Scope::new(ScopeType::Loop(LoopScope::new(i)))),
            &Opcode::Ret { ret } => {
                // Do not display return void; only in case of an early return
                if scopes.depth() > 1 {
                    statement = Some(if f.regtype(ret).is_void() {
                        Statement::ReturnVoid
                    } else {
                        Statement::Return(expr!(ret))
                    });
                } else if !f.regtype(ret).is_void() {
                    statement = Some(Statement::Return(expr!(ret)));
                }
            }
            //endregion

            //region CHECKS
            &Opcode::Throw { exc } => {
                push_stmt!(Statement::Throw(expr!(exc)));
            }
            &Opcode::Rethrow { exc } => {
                push_stmt!(Statement::Throw(expr!(exc)));
            }
            &Opcode::Trap { exc, offset } => {
                // TODO try catch
            }
            &Opcode::EndTrap { exc } => {
                // TODO try catch
            }
            //endregion

            //region VALUES
            &Opcode::ToDyn { dst, src } => {
                push_expr!(i, dst, expr!(src));
            }
            &Opcode::ToVirtual { dst, src } => {
                push_expr!(i, dst, expr!(src));
            }
            &Opcode::New { dst } => {
                // Constructor analysis
                let ty = f.regtype(dst).resolve(&code.types);
                match ty {
                    Type::Obj(_) | Type::Struct(_) => {
                        expr_ctx.push(ExprCtx::Constructor { reg: dst, pos: i });
                    }
                    Type::Virtual { fields } => {
                        expr_ctx.push(ExprCtx::Anonymous {
                            pos: i,
                            fields: HashMap::with_capacity(fields.len()),
                            remaining: fields.len(),
                        });
                    }
                    _ => {
                        push_expr!(
                            i,
                            dst,
                            Expr::Constructor(ConstructorCall::new(f.regtype(dst), Vec::new()))
                        );
                    }
                }
            }
            &Opcode::EnumAlloc { dst, construct } => {
                push_expr!(
                    i,
                    dst,
                    Expr::EnumConstr(f.regtype(dst), construct, Vec::new())
                );
            }
            Opcode::MakeEnum {
                dst,
                construct,
                args,
            } => {
                push_expr!(
                    i,
                    *dst,
                    Expr::EnumConstr(
                        f.regtype(*dst),
                        *construct,
                        args.iter().map(|x| expr!(x)).collect()
                    )
                );
            }
            //endregion
            &Opcode::GetMem { dst, bytes, index } => {
                push_expr!(i, dst, array(expr!(bytes), expr!(index)));
            }
            _ => {}
        }

        // Pass trough all scopes and find which ones should finish
        scopes.push_stmt(statement.take());
    }

    if scopes.depth() != 1 {
        println!("Wait a minute, not all scopes have finished");
    }

    scopes.statements()
}
